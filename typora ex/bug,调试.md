## bug,调试

### 1.优秀程序员

一名优秀的程序员就是一名优秀的侦探

### 2.调试---debug（调式版本）

1. 发现程序错误的存在   程序员（少写bug）---测试工程师（多测bug）---用户
2. 已隔离，消除等方式对错误进行定位
3. 确定错误产生的原因
4. 提出纠正错误的解决办法
5. 对程序错误予以改正，重新测试
5. Debug文件再x64里面

###3.debug,release

* debug（调试版本），它包含了调试信息，并且不做任何优化，便于程序员调试程序
* release（发布版本），它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用

### 4.windows下的调试技巧

1. 调试环境---debug

2. 快捷键（要按fn配合使用）  f5---启动调式 和 f9（切换断点）配合使用 

   **f5启动调试，经常用来直接调到下一个断点处**

   **f9在程序的任意位置设置断点，使得程序在想要的位置随意停下来**

   f10---逐过程

   f11（不会放过任何细节）---逐语句---跳到函数内部

   **shift+fn+f5---退出调试**

   **shift+fn+f11---退出函数内部**

   **ctrl+f5+fn---开始执行不调试**

3. 调试的时候，查看程序当前信息

4. 窗口---自动窗口，局部变量---都会自动的帮你查看信息，缺点是不能自己再手动加

   用的最多的还是 监视窗口  和   内存窗口

5. 调用堆栈  栈---顶上进，顶上出    作用：让你知道哪个函数调用了哪个函数

6. * 第一步调试定位错误
   * 第二步，使用断点（再加上条件），直接跳到错误的位置
   * 解决方案

### 5.栈区的使用习惯

* **先使用高地址处的空间，再使用低地址的空间**(很重要)

* 数组随着下标的增长，地址是由低到高的

  ```c
  int main()
  {
  	int i = 0;
  	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
  	printf("%p\n", &i);
  	printf("%p\n", &arr);
  	for (i = 0; i <= 12; i++)
  	{
  		printf("hehe\n");
  		arr[i] = 0;
  	}
  	system("pause");
  }//所以arr[12]的地址可能就是i的地址
  //将arr[12]改成0的时候，i也变成0了，所以会出现死循环
  ```

* 内存分布可能如下:

  | i    arr[12] |
  | :----------: |
  |   arr[11]    |
  |   arr[10]    |
  |    arr[9]    |
  |    arr[8]    |
  |    arr[7]    |
  |    arr[6]    |
  |    arr[5]    |
  |    arr[4]    |
  |    arr[3]    |
  |    arr[2]    |
  |    arr[1]    |
  |    arr[0]    |

  ### 6.优秀代码

  1. 代码运行正常
  2. bug很少
  3. 效率高
  4. 可读性高
  5. 可维护性高
  6. 注释清晰
  7. 文档齐全

  ### 7.常见的coding技巧

  1. 使用assert

     `assert();`---断言（明确自己的主张）---如果断言内容的正确的，什么事都不发生，如果是错误的，就会报错---断言失败

  2. 尽量使用const

  3. 养成良好的编程风格

  4. 添加必要的注释

  5. 避免代码的陷阱

  ### 8.空指针

  传上去一个空指针，再拿来使用的话，系统会崩

  ### 9.const修饰指针

  * `const int* p`//*p不能改变
  * `int* const p` //p不能改变

  ```c
  int main()
  {
      int num = 10;
      int* p = &num;//可以换男盆友，可以花钱
      const int* p =&num;//可以换男盆友，不能花钱
      int* const p =&num;//不能换男盆友，可以花钱
      const int* const p = &p;//不能换男盆友，不能花钱
      return 0;
  }
  ```

  ### 10.函数返回类型

  如果函数类型是char*---返回的是字符数组**从起始位置到\0的内容**

```c
char* my_strcpy(char* dest, const char* src)//*src不能改变
//如果函数类型是char*---返回的是dest的从起始位置到\0的内容
{
	char* ret = dest;
	assert(dest != NULL);
	assert(src != NULL);
	while (*dest++ = *src++)
	{
		;
	}
	return ret;//返回目的地的起始地址---有点不理解
}

int main()
{
	char arr1[] = "##############";
	char arr2[] = "hello bit";
	printf("arr1变成了%s\n", my_strcpy(arr1,arr2));
	return 0;
}
```

### 6.报错

1. 编译型错误---语法……
2. 链接型错误---函数未定义……
3. 运行时错误---

总之慢慢总结，慢慢积累经验
