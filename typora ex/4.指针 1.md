## 指针

### 1.指针类型

*1*.指针类型决定好指针进行**解引用操作的时候**，**能够访问空间的大小**

```c
int* p //*p能够访问4个字节
char*p //*p能够访问1个字节
double*p//*p能够访问8个字节
```

==所以要选择合适的类型==

指针的最小单元是1个字节,每一个字节都有它对应的编号---即地址

*2*.指针类型决定了，指针走一步走多远（指针的步长）

int* p+1-->4

char* p+1-->1

double* p+1-->8

```c
int main()
{
	int a = 0x11223344;
	int* pa = &a;
	char* pc = &a;//如果只是存地址的话，是没有什么问题的

	printf("%p\n", pa);
	printf("%p\n\n", pa+1);

	printf("%p\n", pc);
	printf("%p\n", pc+1);

	return 0;
}
```

### 2.野指针

指针指向的位置是不可知的（随机的，不正确的，没有明确心智的）

1. 指针未初始化 `int* p`

2. 指针越界---一般会导致系统崩溃

3. ```c
   //例子
   int main()
   {
       int arr[10] = {0};
       int* p =arr;
       int i = 12;
       for(i = 0; i<12;i++)
       {
           p++;//指针越界，跑到数组外面，变成野指针
       }
       return 0;
   }
   ```

4. 指针指向的内存释放

```c
//例子
int* test()
{
    int a = 10;
    return &a;
}
//出函数，a申请的空间也会返回给内存，所以那个地址已不存在
int main()
{
    int* p =test();
    *p = 20;
    return 0;
}
```

### 3.避免野指针的产生

1. 指针初始化
2. 小心指针越界
3. 如果不想让一个指针指向一个地址，可以先加上NULL
4. 指针使用之前检查有效性

### 4.空间问题

**要使用空间，必须向内存申请（这个时候的空间才是你可以使用的），不然就是非法访问，野指针就是这样的“流氓”**

### 5.指针-指针

其实是中间元素的个数

arr[9] - arr[0] == 9,//除去arr[0],向右开始数到arr[9]，的元素个数

### 6.标准

允许指向数组元素的指针与指向数组**最后一个元素后面的那个内存**位置的指针比较，但是不允许与指向***第一个元素之前的那个内存***位置 的指针进行标胶



