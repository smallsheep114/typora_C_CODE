### 12.动态内存分配

想要开辟多大空间，就开辟多大空间

### 1.内存

1. 栈区

   局部变量，函数的形式参数

2. 堆区

   动态内存分配

3. 静态区

   全局变量，静态变量（static int a=  10）

### 2.c99--增加了变长数组的概念

只是大部分编译器，不支持

但是**gcc编译器**支持c99标准

### 3.动态内存分配函数

1. malloc

   开辟成功，返回空间的初始地址void*

   开辟失败，返回NULL

2. free

   释放那段空间，**记住再加一个p = NULL**;这样就会更加的安全

3. calloc

   效率稍微低一点，但是它会帮忙，把每个字节的内容都初始化为0

4. realloc

   调整动态内存开辟空间的大小

   ==realloc使用注意事项==

   1. 如果后面有足够的空间调整，那么就在后面重新开辟，并且返回的指针和原来的是一样的

   2. 但是，如果后面没有足够的类型去调整空间，那么会重新找一块空间，把原来的的内容拷贝到新的空间里面，原来的空间释放掉，返回的指针是一个新的指针。

      **所有，当调整空间的时候，p的值是可能发生改变的**

   3. 但是空间不够，就返回了空指针了

      为了不造成我们最初的指针的丢失，我们需要一个新的变量来接受realloc，如果不是NULL，就给p

   **realloc**--实现了动态内存的灵活性，想多一下就多开辟一点，实现扩容，但具有一定的风险性，使用的时候要注意

### 4.常见的动态内存分配错误

动态内存出错，电脑会卡死

==动态内存空间，是由一个指针来维护的==，不要轻易改变p的位置

1. 一定要**对返回值进行判断**，可能是**空指针**，不要对空指针进行解引用操作了
2. 对动态内存空间的**越界访问**
3. 对**非动态内存的释放**
4. 使用**free释放动态开辟内存的一部分**  不要轻易改变p的位置，p是用来维护这块动态内存空间的
5. 对**同一块动态内存空间多次释放**
   1. 如何避免，谁开辟，谁回收
   2. 写一个p = NULL,这样的话，再一次进行free(p)就不会出错了
6. 动态内存空间**忘记释放**（内存泄漏）

### 5.打印的方式

`printf("abcdef");`

`printf(str);`--都是可以的

### 6.使用函数时注意事项

通过函数修改实参的实质，可以通过形参（解引用）找到实参

1. 如果你想**修改实参**，那必须是要传实参的地址（**址传递**）

2. 如果**不需要修改实参**，那么不必要上传实参的地址（**值传递**）

   如果你非要进行**值传递**，记得**加上`const`**--不能解引用（取内容）

函数：

1. 可以通过，址传递进项间接修改
2. 也可以通过return语句进行直接修改

### 7.对空间释放的理解

1. 对这块内存空间的释放，咱们不能去访问了
2. ==更需要注意的是，里面的内容也成为了随机值==--非法访问

### 8.返回栈/堆/静态空间地址

1. 如果在一个函数中，返回值是栈空间的地址，虽然你得到了他的地址，但这块空间的内容已经释放了，内容成了随机值

   如果你使用的话，就成了非法访问了

2. 如果在一个函数中，返回值是堆空间的地址，对空间的地址是没有释放的，所以我们可以自己使用，里面的内容也不会消失，这块空间是由我们自己来释放的。

**所以，可以返回堆空间/静态区空间，千万不要返回栈空间，特别容易出错**

### 9.计算机内存

1. 栈区--局部变量

   堆区--动态内存分配（malloc，calloc……）

   静态区--全局，静态变量

   堆区，静态区--程序结束后也会回收（但堆区最好程序员自己回收）

2. 内核空间--操作系统才能使用

3. 内存映射区

4. 代码段

   可执行代码

   只读常量--（常量字符串）

### 10.柔性数组（新鲜玩意C99）--零长度数组

**结构体**最后一个成员**数组**，**大小可以是未知的**(注意数组是最后一个数组哦)

特点：

1. 数组前面，至少要有一个成员
2. arr不占空间
3. 用`malloc`去开辟动态内存空间

```c
//柔性数组--代码演示
typedef struct
{
	int n;
	int arr[];//--arr指针，指向紧连着n空间后面的首地址（理解）
}student;

int main()
{
	//student stu; --- 连变量都不需要创建，就可以使用
	//printf("%d\n", sizeof(student));//柔性数组的大小不算入结构体类型的空间大小
	student* pf = malloc(sizeof(student) + sizeof(int) * 5);//数组长度为5
	if (pf == NULL)
	{
		perror("allovacts memory blocks:");
		return 0;
	}
	pf->n = 100;
	int i = 0;
	for (i = 0; i < 5; i++)
	{
		pf->arr[i] = i;
	}
	//调整柔性数组的长度
	student* ptr = realloc(pf,sizeof(student) + 10 * sizeof(int));
	if (ptr != NULL)
	{
		pf = ptr;
	}
	for (i = 5; i < 10; i++)
	{
		pf->arr[i] = i;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", pf->arr[i]);
	}
	//释放
	free(pf);
	pf = NULL;
	return 0;
}
```

柔性数组的优点

1. 柔性数组`arr`不占空间
2. 内存**布局是连接在一起的**  `int num`和`arr`是内存是连接在一起的，**访问效率更高**。
3. 由于柔性数组空间分配上的连续性，**释放空间也变得更加方便**(`free`)
4. `malloc`使用的越多，内存碎片就越多，而柔性数组就更好地利用了内存碎片，提高了**内存利用率**
5. 

### 10.访问速度

1. 寄存器(cpu)--寄存器拿的习惯--拿周边的数据，所以内存越连续，cpu拿的越多，访问越高效
2. cache--高速缓存
3. 内存
4. 硬盘

### 11.酷壳--陈皓

文章---《程序员练级攻略》--居然需要付费观看文章

### 12.动态通讯录

默认3个空间，录满的时候，进行扩容，每次增加2个空间



