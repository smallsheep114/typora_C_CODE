## 10.自定义类型

### 1.结构体的内存对齐规则--理解对齐这个概念

1. **第一个成员**在结构体变量**偏移量为0**的地址处

2. **其他成员**变量要对齐到(**对齐数**)的**整数倍的地址处**

   **对齐数**  = 编译器默认的一个对齐数 与 该成员大小的 **较小值**（二者的一个较小值）

   vs中默认的对齐数为**8**

3. **结构体总大小**为**最大对齐数**(每个成员变量都有一个对齐数)的**整数倍**

4. 如果嵌套了结构体的情况，**嵌套的结构体对齐到自己的最大对齐数的整数倍处**，结构体的**整体大小**就是所有**最大对齐数**(**含嵌套结构体的对齐数**)的**整数倍**

### 2.设计结构体技巧

考虑到结构体内存的对齐规则，我们既要满足对齐，又要节省空间，我们可以**让占用空间小的成员尽量集中在一起**

```c
struct s1
{
    char c1;
    int i;
    char c2;
};//明显第二种写法更加节省空间
struct s2
{
    char c1;
    char c2;
    int i;
}
```

### 3.位段

位段，位：**二进制**位     写法：类型+:+数字（==数字不能超过32或8==）

只用于整形家族    `int`    `char`

位段的内存分配

1. 位段成员可以是`int`,`unsigned int`,`signed int`或者`char`（也属于整形家族）类型
2. 位段的空间上是按照需要，以**4个字节(int)**，或者**1个字节(char)**的方式来开辟的
3. 位段涉及很多不确定因素，位段是不跨平台的，注意可移植的程序应该避免使用位段

### 4.visual平台下，位段规则

int类型，开辟4个字节的空间，要是不够了，**剩余的部分舍去掉**，再**重新开辟4字节的空间**

char类型类似

### 5.枚举

1. 枚举的使用

   ```c
   enum Sex//把性别一一列举出来
   {
   	//枚举的可能取值--枚举常量--可以给他们赋初值，不赋初值的话就是默认值0，1，2
   	//默认值是前面的值+1，前面没有的话，默认就是0
   	MALE ,//0
   	FEMALE = 9 ,//1
   	SECRET //2
   };
   
   int main()
   {
   	enum Sex s = MALE;
   	//error//MALE = 0;//这个不可以修改，因为枚举常量是常量不可以修改
   	printf("%d %d %d\n", MALE, FEMALE, SECRET);
   	return 0;
   }
   ```

   

2. 枚举的优点

   1. 可读性和可维护性
   2. 和#define相比，类型检查，更加严谨     #define定义的内容  没有类型
   3. 防止了命名污染（封装）
   4. 方便定义
   5. 方便调试

### 6.联合体的使用

```c
int check_sys()
{
	union Un//创建一个联合体类型
	{
		char c;
		int i;
	}u;//可以直接在这创建
	u.i = 1;
	return u.c;
}

int main()
{
	
	int ret = check_sys();
	if (ret == 1)
	{
		printf("小端");
	}
	else
	{
		printf("大端");
	}
	return 0;
}
```

### 7.联合体**大小计算**

1. 联合的大小至少是最大成员的大小
2. 当最大成员大小不是最大对齐数的整数倍的时候，就要**对齐到最大对齐数的整数倍**

==数组大对齐数，按数组元素的对齐数来计算==

